<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- <link rel="stylesheet" href="./11.css"> -->
  <style>
    @import url(11.css);
  </style>
</head>

<body>
  <script>
    // 输入：n = 19
    // 输出：true
    var threeSum = function (nums) {
      let ans = []
      const len = nums.length
      if (nums == null || len < 3) return ans
      nums.sort((a, b) => a - b) // 排序
      for (let i = 0; i < len; i++) {
        if (nums[i] > 0) break // 如果当前数字大于0，则三数之和一定大于0，所以结束循环
        if (i > 0 && nums[i] == nums[i - 1]) continue // 去重
        let L = i + 1
        let R = len - 1
        while (L < R) {
          const sum = nums[i] + nums[L] + nums[R]
          if (sum == 0) {
            ans.push([nums[i], nums[L], nums[R]])
            // while (L < R && nums[L] == nums[L + 1]) L++ // 去重
            // while (L < R && nums[R] == nums[R - 1]) R-- // 去重
            L++
            R--
          }
          else if (sum < 0) L++
          else if (sum > 0) R--
        }
      }
      return ans
    }
    // let res = threeSum([-1, 0, 1, 2, -1, -4])
    // console.log(res);
    var canConstruct = function (ransomNote, magazine) {
      let ran = {}
      for (let i = 0; i < ransomNote.length; i++) {
        ran[ransomNote[i]] = (ran[ransomNote[i]] || 0) + 1
      }
      for (let j = 0; j < magazine.length; j++) {
        if (ran[magazine[j]]) {
          ran[magazine[j]]--
          continue
        }
      }
      return Object.values(ran).every(v => !v)
    }
    // let res = canConstruct('abc', 'abac')
    // console.log(res);


    // 输入：nums = [1, 0, -1, 0, -2, 2], target = 0
    // 输出：[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]
    var fourSum = function (nums, target) {
      let len = nums.length
      if (len < 4) return []
      nums.sort((a, b) => a - b)
      let ans = []
      for (let i = 0; i < len - 3; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) continue
        for (let j = i + 1; j < len - 2; j++) {
          let left = j + 1, right = len - 1
          if (j > i + 1 && nums[j] === nums[j - 1]) continue
          while (left < right) {
            let sum = nums[i] + nums[j] + nums[left] + nums[right]
            if (sum === target) {
              ans.push([nums[i], nums[j], nums[left], nums[right]])
              while (left < right && nums[left] === nums[left + 1]) left++
              while (left < right && nums[right] === nums[right - 1]) right--
              left++
              right--
            } else if (sum < target) {
              left++
            } else if (sum > target) {
              right--
            }
          }
        }
      }
      return ans
    }
    // let res = fourSum([1, 0, -1, 0, -2, 2], 0)
    // console.log(res);



    var reverseString = function (s) {
      let left = 0, right = s.length - 1
      while (left < right) {
        let temp = s[left]
        s[left] = s[right]
        s[right] = temp
        left++
        right--
      }
      return s
    }

    // let res = reverseString(["h", "e", "l", "l", "o"])
    // console.log(res);



    var reverseStr = function (s, k) {
      let len = s.length
      const str = s.split('')
      for (let i = 0; i < len - 1; i += (2 * k)) {
        let r = i + (k - 1), l = i
        while (l < r) {
          [str[l], str[r]] = [str[r], str[l]]
          l++
          r--
        }
      }
      return str.join('')
    }
    // let res = reverseStr("abcdefg", 2)
    // console.log(res);
    let wjc = [1, 2]
    {
      [wjc[0], wjc[1]] = [wjc[1], wjc[0]]
    }
    // console.log(wjc);


    // 输入：tokens = ["2", "1", "+", "3", "*"]
    // 输出：9
    // 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
    var evalRPN = function (tokens) {
      let stack = []
      const map = {
        '+': (a, b) => {
          let sum = a + b
          stack.push(sum)
        },
        '-': (a, b) => {
          let sum = b - a
          stack.push(sum)
        },
        '*': (a, b) => {
          let sum = a * b
          stack.push(sum)
        },
        '/': (a, b) => {
          let sum = parseInt(b / a)
          stack.push(sum)
        }
      }
      for (let i = 0; i < tokens.length; i++) {
        let a = '', b = ''
        if (map[tokens[i]]) {
          a = stack.pop()
          b = stack.pop()
          map[tokens[i]](a, b)
        } else {
          stack.push(parseInt(tokens[i]))
        }

        // switch (tokens[i]) {
        //   case '+':
        //     a = stack.pop(), b = stack.pop()
        //     stack.push(a + b)
        //     break
        //   case '-':
        //     a = stack.pop(), b = stack.pop()
        //     stack.push(b - a)
        //     break
        //   case '*':
        //     a = stack.pop(), b = stack.pop()
        //     stack.push(a * b)
        //     break
        //   case '/':
        //     a = stack.pop(), b = stack.pop()
        //     stack.push(parseInt(b / a))
        //     break
        //   default:
        //     stack.push(parseInt(tokens[i]))
        //     break
        // }
      }
      return stack[0]
    }
    // let res = evalRPN(["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"])
    // console.log(res);

    // 输入: nums = [1, 1, 1, 2, 2, 3], k = 2
    // 输出: [1, 2]
    var topKFrequent = function (nums, k) {
      const map = new Map()
      nums.forEach(n => {
        map.set(n, map.has(n) ? map.get(n) + 1 : 1)
      })
      // 首先将字典转成数组，然后对数组中的第二个元素（频度）从小到大排序
      const list = Array.from(map).sort((a, b) => b[1] - a[1])
      // 截取频率前k高的元素
      return list.slice(0, k).map(n => n[0])
    }
    // let res = topKFrequent([1, 1, 1, 2, 2, 3], 2)
    // console.log(res);



    var maxSlidingWindow = function (nums, k) {
      if (nums.length == 1 || k == 1) return nums
      let res = []
      for (let i = 0; i <= nums.length - k; i++) {
        let test = [], key = k
        while (key > 1) {
          test.push(nums[i + (key - 1)])
          key--
        }
        res.push(Math.max(nums[i], ...test))
      }
      console.log(res)
      return res
    }
    // 输入：nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3
    // 输出：[3, 3, 5, 5, 6, 7]
    // maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 4)
    var postorderTraversal = function (root) {
      let res = []
      const dfs = function (root) {
        if (root == null) {
          return
        }
        dfs(root.left)
        dfs(root.right)
        res.push(root.val)
      }
      dfs(root)
      return res
    }
    postorderTraversal([])



  </script>

</body>

</html>